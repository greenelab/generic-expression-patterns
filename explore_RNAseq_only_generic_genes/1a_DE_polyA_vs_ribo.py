# ---
# jupyter:
#   jupytext:
#     formats: ipynb,py
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.9.1+dev
#   kernelspec:
#     display_name: Python [conda env:generic_expression] *
#     language: python
#     name: conda-env-generic_expression-py
# ---

# ## Differential expression of polyA-selected vs ribo-depleted
#
# This notebook tests the hypothesis that these uncorrelated genes are due to difference in platforms. Specifically, we believe that these genes are those that are differentially expressed using ribo-depleted vs polyA-selection. There may exist some genes that are frequently found to be differentially expressed using polyA-selection and some genes that are frequently found to be differentially expressed using the ribo-depletion strategy. Since our training compendium is recount2, which includes many different types of experiments therefore different selection strategies, its possible that these gene biases that result from differences in processing are found by SOPHIE but not found by Crow et. al. which uses array technology.
#
# This notebook compares 6 matched samples generated using both polyA-selected and ribo-depleted strategies. Then highlights the DEGs on the correlation plot to determine if the genes that are generic in RNA-seq only are those that are due to differences in protocol.

# +
# %load_ext autoreload
# %load_ext rpy2.ipython
# %autoreload 2

import os
import sys
import pandas as pd
import numpy as np

from rpy2.robjects import pandas2ri
from ponyo import utils
from generic_expression_patterns_modules import stats, ranking

pandas2ri.activate()
np.random.seed(123)

# +
# Read in config variables
base_dir = os.path.abspath(os.path.join(os.getcwd(), "../"))

config_filename = os.path.abspath(
    os.path.join(base_dir, "configs", "config_human_general.tsv")
)

params = utils.read_config(config_filename)
local_dir = params["local_dir"]
dataset_name = params["dataset_name"]
col_to_rank_genes = params["rank_genes_by"]
project_id = params["project_id"]
# -

# ## Differential expression analysis

# Our raw data was generated by [RSEM](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-12-323).
#
# **RSEM**:
# * A software package for quantifying gene and isoform abundances from single-end or paired-end RNA-Seq data
#
# _Input_: reference transcript sequences (FASTA), RNA-seq reads
#
# _Quantification_:
# * Reads are aligned to reference transcripts
# * After alignment, RSEM computes ML estimate of abundances using EM to estimate the probability that a read is derived from a transcript
#
# _Output_:
# * Gene-level estimates
# * Isoform-level estimates
#
# **Quantification level**:
# * A _gene_ is a bounded region of a chromosome within which transcription occurs.
# * The gene (DNA sequence) is transcribed into RNA transcripts.
#     * In bacteria, these RNA transcripts act as mRNA that can be translated into protein.
#     * In eukaryotes, the transcript RNA is pre-mRNA and must undergo additional processing (post-transcriptional modifications) before it can be translated.
# * This processing includes addition of a protective cap and tail, splicing to remove introns. So genes can have multiple mRNA or _transcripts_(which can encode different proteins) through the process of alternative splicing, where pre-mRNA transcripts are assembled in different ways.
#
# Note: In terms of terminology, people tend to refer to the mRNAs as _transcripts_ while they use the term _isoform_ tend to refer more to the protien structure of the mRNA. In RNA-seq world, we can think of isoform-level = transcript-level.
#
# **DESeq2 normalization and comparison**:
#
# Normalization is needed to perform a fair comparison.
#
# The main factors considered during normalization include:
# 1. sequence depth/coverage = the number of unique reads that map to a region
# 2. gene length = longer genes tend to have more reads mapped
# 3. RNA composition = what genes are expressed and how active
#
# When performing a DE analysis, since we're comparing match gene pairs, we only need to consider sequence depth and RNA composition. DESeq2 accounts for these in its median ratio, which scales sample counts by median of ratios for sample counts vs reference pseudo count per gene: https://hbctraining.github.io/DGE_workshop/lessons/02_DGE_count_normalization.html
#
# Different function calls to create DESeq object depending on the input data. These objects are then passed into [DESeq](https://www.rdocumentation.org/packages/DESeq2/versions/1.12.3/topics/DESeq).
#
# * `DESeqDataSetFromTximport()`: For data generated by RSEM, Kallisto, Salmon, Sailfish
# * `DESeqDataSetFromMatrix()`: For raw count matrix, expects integer values
# * `DESeqDataSet()`: For RangedSummarizedExperiment (RSE) data, like from recount2
#
# Documentation recommends using `tximport` and then calling `DESeqDataSetFromTximport` for RSEM estimated count data in order to get counts corrected for by gene length: https://support.bioconductor.org/p/94003/#94028.
#
# [tximport](https://rdrr.io/bioc/tximport/src/R/tximport.R):
# * imports transcript-level estimates from various external software and optionally summarizes abundances, counts, and transcript lengths to the gene-level (default) or transcript-level matrices.
#
# _Input_ a list of files containing:
# * transcript-level abundances (TPM/FPKM): Normalized read count. Number of reads mapped to a given transcript normalized by transcript length and/or library size.
# * estimated/expected counts: An estimate of the number of reads derived from a given transcript/isoform or gene. We can only get an estimate for this quantity since reads do not often map uniquely to a single transcript/isoform.
# * effective lengths: The number of possible start positions for a read within a transcript
#
# _Output_ a list of matrices containing:
# If the user requests just the transcript-level data, then combine data across samples and return. Otherwise summarizes to gene-level using `tx2gene` parameter: a two-column dataframe linking transcript id (column 1) to gene id (column 2).
# * abundance matrix
# * count matrix
# * length matrix
#
# In our case, since RSEM is returning gene-level summaries, `tximport` will just combines the gene-level summaries across files into a matrix.
#
# The dataset we have is a matrix of estimated counts that were combined across samples. We don't have the individual raw data files output from RSEM, which is needed to call tximport. However, it looks like `tximport` would have been redundant given what we mentioned above. Here we are rounding the combined RSEM estimated counts and using `DESeqDataSetFromMatrix()`. Given the first step of `DESeqDataSetFromTximport` is rounding the counts, we anticipate this step to be ok. Looks like rounding is also performed for `DESeqDataSet()` as well: https://rdrr.io/bioc/DESeq2/src/R/AllClasses.R.
#
# In general, the recommendation to use `tximport` might be necessary for the case where we have transcript-level data.

# +
mapped_expression_filename = "polya_ribo_expression.tsv"
processed_expression_filename = "polya_ribo_expression_processed.tsv"
metadata_filename = "polya_ribo_sample_grouping.tsv"

stats.process_samples_for_DESeq(
    mapped_expression_filename,
    metadata_filename,
    processed_expression_filename,
)

# + magic_args="-i metadata_filename -i processed_expression_filename -i local_dir -i base_dir" language="R"
#
# source(paste0(base_dir, '/generic_expression_patterns_modules/DE_analysis.R'))
#
# # File created: "<local_dir>/DE_stats/DE_stats_template_data_<project_id>_real.txt"
# get_DE_stats_DESeq(metadata_filename,
#                    "polyA_vs_ribo",
#                    processed_expression_filename,
#                    "template",
#                    local_dir,
#                    "pbta")

# +
# Get DEGs
template_DE_stats_filename = os.path.join(
    local_dir, "DE_stats", "DE_stats_template_data_polyA_vs_ribo_pbta.txt"
)

template_DE_stats = pd.read_csv(
    template_DE_stats_filename, sep="\t", header=0, index_col=0
)

selected = template_DE_stats[
    (template_DE_stats["padj"] < 0.01) & (abs(template_DE_stats["log2FoldChange"]) > 1)
]
DEGs = list(selected.index)
print(len(DEGs))
selected.head()
# -

# ## Plot

# +
# Load gene_summary_filename
gene_summary_filename = os.path.join(
    base_dir, dataset_name, f"generic_gene_summary_{project_id}.tsv"
)

summary_gene_ranks = pd.read_csv(gene_summary_filename, sep="\t", index_col=0, header=0)
# -

summary_gene_ranks.loc[DEGs]

# +
# Get generic genes identified by Crow et. al.
DE_prior_filename = params["reference_gene_filename"]
ref_gene_col = params["reference_gene_name_col"]
ref_rank_col = params["reference_rank_col"]

figure_filename = f"gene_ranking_{col_to_rank_genes}_highlight_polyA_vs_ribo.svg"

corr, shared_ranking = ranking.compare_gene_ranking_highlight(
    summary_gene_ranks,
    DE_prior_filename,
    ref_gene_col,
    ref_rank_col,
    DEGs,
    figure_filename,
)
# -

# **Takeaway**:
# Looks like the genes that differentiate between the two protocals are not localized to the bottom right.
