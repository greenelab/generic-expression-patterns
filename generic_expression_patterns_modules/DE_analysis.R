# Functions to perform DE analysis using
# Limma (microarray) and DESeq2 (RNA-seq)

# Load libraries
library("limma")
library("DESeq2")

get_DE_stats_limma <- function(metadata_file,
                               experiment_id,
                               expression_file,
                               data_type,
                               local_dir,
                               run) {

  # This function performs DE analysis using expression data in expression_file
  # where samples are grouped based on metadata_file
  #
  # Arguments
  # ---------
  # metadata_file: str
  #   File containing mapping between sample id and group
  #
  # experiment_id: str
  #   Experiment id used to label saved output filee
  #
  # expression_file: str
  #   File containing gene expression data
  #   Expression data should be of the form sample x gene
  #
  # data_type: str
  #   Either 'template' or 'simulated' to label saved output file
  #
  # local_dir: str
  #   Directory to save output files to
  #
  # run: str
  #   Used as identifier for different simulated experiments

  # Read in data
  # Note the expression data is transposed to gene x sample in order to run Limma
  expression_data <- t(
    as.matrix(
      read.csv(expression_file, sep="\t", header=TRUE, row.names=1)
    )
  )
  metadata <- as.matrix(
    read.csv(metadata_file, sep="\t", header=TRUE, row.names=1)
  )

  # NOTE: It make sure the metadata is in the same order
  # as the column names of the expression matrix.
  group <- interaction(metadata[,1])

  mm <- model.matrix(~0 + group)

  ## DEGs of simulated data
  # lmFit expects input array to have structure: gene x sample
  # lmFit fits a linear model using weighted least squares for each gene:
  fit <- lmFit(expression_data, mm)

  # Comparisons between groups (log fold-changes) are obtained as contrasts of
  # these fitted linear models:
  # Samples are grouped based on experimental condition
  # The variability of gene expression is compared between these groups
  contr <- makeContrasts(group2 - group1, levels = colnames(coef(fit)))

  # Estimate contrast for each gene
  tmp <- contrasts.fit(fit, contr)

  # Empirical Bayes smoothing of standard errors (shrinks standard errors
  # that are much larger or smaller than those from other genes towards the average standard error)
  tmp <- eBayes(tmp)

  # Get significant DEGs
  top.table <- topTable(tmp, sort.by = "P", n = Inf)
  all_genes <-  as.data.frame(top.table)

  # Find all DEGs based on adjusted p-value cutoff
  threshold <- 0.001
  num_sign_DEGs <- all_genes[all_genes[,'adj.P.Val']<threshold & abs(all_genes[,'logFC'])>1,]

  # Save summary statistics of DEGs
  if (data_type == "template") {
    out_file = paste(local_dir, "DE_stats/DE_stats_template_data_", experiment_id,"_", run, ".txt", sep="")
  } else if (data_type == "simulated") {
    out_file = paste(local_dir, "DE_stats/DE_stats_simulated_data_", experiment_id,"_", run, ".txt", sep="")
  }
  write.table(all_genes, file = out_file, row.names = T, sep = "\t", quote = F)

  return(nrow(num_sign_DEGs))

}

get_DE_stats_DESeq <- function(metadata_file,
                               experiment_id,
                               expression_file,
                               data_type,
                               local_dir,
                               run) {

  # This function performs DE analysis using DESeq.
  # Expression data in expression_file are grouped based on metadata_file
  #
  # Arguments
  # ---------
  # metadata_file: str
  #   File containing mapping between sample id and group
  #
  # experiment_id: str
  #   Experiment id used to label saved output filee
  #
  # expression_file: str
  #   File containing gene expression data
  #
  # data_type: str
  #   Either 'template' or 'simulated' to label saved output file
  #
  # local_dir: str
  #   Directory to save output files to
  #
  # run: str
  #   Used as identifier for different simulated experiments

  expression_data <- t(as.matrix(read.csv(expression_file, sep="\t", header=TRUE, row.names=1)))
  metadata <- as.matrix(read.csv(metadata_file, sep="\t", header=TRUE, row.names=1))

  print("Checking sample ordering...")
  print(all.equal(colnames(expression_data), rownames(metadata)))

  group <- interaction(metadata[,1])

  mm <- model.matrix(~0 + group)

  # Note about DESeq object
  # Different function calls to create DESeq object depending on the input data.
  # These objects are then passed into [DESeq](https://www.rdocumentation.org/packages/DESeq2/versions/1.12.3/topics/DESeq).
  #
  # * `DESeqDataSetFromTximport()`: For data generated by RSEM, Kallisto, Salmon, Sailfish
  # * `DESeqDataSetFromMatrix()`: For raw count matrix, expects integer values
  # * `DESeqDataSet()`: For RangedSummarizedExperiment (RSE) data, like from recount2
  #
  # Documentation recommends using `tximport` and then calling `DESeqDataSetFromTximport` for RSEM (or other methods listed above)
  # estimated count data in order to get counts corrected for by gene length: https://support.bioconductor.org/p/94003/#94028.
  #
  # [tximport](https://rdrr.io/bioc/tximport/src/R/tximport.R):
  # * imports transcript-level estimates from various external software and optionally summarizes abundances,
  # counts, and transcript lengths to the gene-level (default) or transcript-level matrices.
  #
  # _Input_ a list of files containing:
  # * transcript-level abundances (TPM/FPKM): Normalized read count. Number of reads mapped to a given
  # transcript normalized by transcript length and/or library size.
  # * estimated/expected counts: An estimate of the number of reads derived from a given transcript/isoform
  # or gene. We can only get an estimate for this quantity since reads do not often map uniquely to a single transcript/isoform.
  # * effective lengths: The number of possible start positions for a read within a transcript
  #
  # _Output_ a list of matrices containing:
  # If the user requests just the transcript-level data, then combine data across samples and return.
  # Otherwise summarizes to gene-level using `tx2gene` parameter: a two-column dataframe linking transcript id (column 1) to gene id (column 2).
  # * abundance matrix
  # * count matrix
  # * length matrix
  #
  # For the analysis in notebook: explore_uncorrelated_genes/1a_DE_polyA_vs_ribo.ipynb
  # We are using data generated by RSEM, which returned gene-level summaries.
  # In this case, `tximport` will just combine the gene-level summaries across files into a matrix.
  #
  # The dataset we have is a matrix of estimated counts that were combined across samples. We don't have the individual raw data files output from RSEM,
  # which is needed to call tximport. However, it looks like `tximport` would have been redundant given what we mentioned above.
  # Here we are rounding the combined RSEM estimated counts and using `DESeqDataSetFromMatrix()`.
  # Given the first step of `DESeqDataSetFromTximport` is rounding the counts, we anticipate this step to be ok.
  # https://rdrr.io/bioc/DESeq2/src/R/AllClasses.R.
  #
  # In general, the recommendation to use `tximport` might be necessary for the case where we have transcript-level data.
  #
  # For the analysis in notebook: human_general_analysis/2_identify_generic_genes_pathways.ipynb
  # We are using RangedSummarizedExperiments from recount2.
  # We combined these RSEs in download_recount2_data.R so we cannot use `DESeqDataSet()` which expects SE inputs.
  # Again, we round our combined RSE data and use `DESeqDataSetFromMatrix()`.
  # Looks like rounding is also performed for `DESeqDataSet()` as well.

  ddset <- DESeqDataSetFromMatrix(expression_data, colData=metadata, design = ~group)

  deseq_object <- DESeq(ddset)

  # Note parameter settings:
  # `independentFilter=False`: We have turned off the automatic filtering, which
  # filter filter out those tests from the procedure that have no, or little
  # chance of showing significant evidence, without even looking at their test statistic.
  # Typically, this results in increased detection power at the same experiment-wide
  # type I error, as measured in terms of the false discovery rate.
  # cooksCutoff=True (default): Cook's distance as a diagnostic to tell if a single sample
  # has a count which has a disproportionate impact on the log fold change and p-values.
  # These genes are flagged with an NA in the pvalue and padj columns
  deseq_results <- results(deseq_object, independentFiltering=FALSE)

  deseq_results_df <-  as.data.frame(deseq_results)

  # Save summary statistics of DEGs
  if (data_type == "template") {
    out_file = paste(local_dir, "DE_stats/DE_stats_template_data_", experiment_id,"_", run, ".txt", sep="")
  } else if (data_type == "simulated") {
    out_file = paste(local_dir, "DE_stats/DE_stats_simulated_data_", experiment_id,"_", run, ".txt", sep="")
  }
  write.table(deseq_results_df, file = out_file, row.names = T, sep = "\t", quote = F)
}
